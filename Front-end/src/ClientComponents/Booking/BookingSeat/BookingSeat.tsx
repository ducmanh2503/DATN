import { useEffect, useState, useCallback, useRef, useMemo } from "react";
import "./BookingSeat.css";
import { Card, Tooltip, message } from "antd";
import { useMessageContext } from "../../UseContext/ContextState";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import pusher from "../../../utils/pusher";

interface SeatType {
  id: number;
  roomId: number;
  row: string;
  column: string;
  seatCode: string;
  seatType: string;
  price: number;
  dayType: "weekday" | "weekend" | "holiday";
  status?: string;
  heldByCurrentUser?: boolean;
}

const BookingSeat = ({
  className,
  onContinue,
  onSeatHoldSuccess,
}: {
  className?: string;
  onContinue: (handler: () => void) => void;
  onSeatHoldSuccess?: () => void;
}) => {
  const {
    setNameSeats,
    setQuantitySeats,
    nameSeats,
    setTotalSeatPrice,
    totalSeatPrice,
    setTotalPrice,
    roomIdFromShowtimes,
    showtimeIdFromBooking,
    setHoldSeatId,
    holdSeatId,
    selectedSeatIds,
    setSelectedSeatIds,
    shouldRefetch,
    setShouldRefetch,
  } = useMessageContext();

  const token = localStorage.getItem("auth_token");
  const queryClient = useQueryClient();

  const [seats, setSeats] = useState<
    Record<string, { isHeld?: boolean; heldByUser?: boolean }>
  >({});
  const [isPusherRegistered, setIsPusherRegistered] = useState(false);
  const pusherEventHandlersRegistered = useRef(false);
  const pollingIntervalRef = useRef<number | null>(null);

  // T·∫°o ref ƒë·ªÉ theo d√µi tr·∫°ng th√°i hi·ªán t·∫°i kh√¥ng g√¢y render
  const nameSeatsRef = useRef(nameSeats);
  const selectedSeatIdsRef = useRef(selectedSeatIds);

  // C·∫≠p nh·∫≠t ref khi state thay ƒë·ªïi
  useEffect(() => {
    nameSeatsRef.current = nameSeats;
    selectedSeatIdsRef.current = selectedSeatIds;
  }, [nameSeats, selectedSeatIds]);

  const { data: getUserId } = useQuery({
    queryKey: ["getUserId"],
    queryFn: async () => {
      try {
        const { data } = await axios.get("http://localhost:8000/api/user", {
          headers: { Authorization: `Bearer ${token}` },
        });
        return data.id;
      } catch (error) {
        console.error("L·ªói khi l·∫•y userId:", error);
        return null;
      }
    },
    enabled: !!token,
  });

  const userId = getUserId || null;

  // T·ªëi ∆∞u h√≥a vi·ªác l√†m m·ªõi d·ªØ li·ªáu
  const refetchSeatsData = useCallback(() => {
    if (roomIdFromShowtimes && showtimeIdFromBooking) {
      queryClient.invalidateQueries({
        queryKey: ["matrixSeats", roomIdFromShowtimes, showtimeIdFromBooking],
      });
      // Ch·ªâ g·ªçi refetch khi c·∫ßn thi·∫øt
      if (!shouldRefetch) {
        setShouldRefetch(true);
      }
    }
  }, [
    queryClient,
    roomIdFromShowtimes,
    showtimeIdFromBooking,
    shouldRefetch,
    setShouldRefetch,
  ]);

  const { data: matrixSeats, refetch: refetchMatrix } = useQuery({
    queryKey: ["matrixSeats", roomIdFromShowtimes, showtimeIdFromBooking],
    queryFn: async () => {
      if (!roomIdFromShowtimes || !showtimeIdFromBooking) {
        return null;
      }
      try {
        const { data } = await axios.get(
          `http://localhost:8000/api/get-seats-for-booking/${roomIdFromShowtimes}/${showtimeIdFromBooking}`,
          {
            headers: { Authorization: `Bearer ${token}` },
          }
        );
        return data;
      } catch (error) {
        console.error("üö® L·ªói khi l·∫•y th√¥ng tin gh·∫ø:", error);
        return null;
      }
    },
    refetchOnWindowFocus: false, // T·∫Øt refetch t·ª± ƒë·ªông khi focus ƒë·ªÉ tr√°nh v√≤ng l·∫∑p
    // staleTime: 0,
    // cacheTime: 0,
    enabled: !!roomIdFromShowtimes && !!showtimeIdFromBooking && !!token,
  });

  // T√°ch findSeatCodeById v√† findSeatById th√†nh c√°c h√†m memo
  const findSeatCodeById = useCallback(
    (seatId: number): string | null => {
      if (!matrixSeats) return null;
      for (const rowKey in matrixSeats) {
        const row = matrixSeats[rowKey];
        for (const seatKey in row) {
          const seat = row[seatKey];
          if (seat.id === seatId) {
            return seat.seatCode;
          }
        }
      }
      return null;
    },
    [matrixSeats]
  );

  const findSeatById = useCallback(
    (seatId: number): SeatType | null => {
      if (!matrixSeats) return null;
      for (const rowKey in matrixSeats) {
        const row = matrixSeats[rowKey];
        for (const seatKey in row) {
          const seat = row[seatKey];
          if (seat.id === seatId) {
            return seat;
          }
        }
      }
      return null;
    },
    [matrixSeats]
  );

  // T√°ch v√† t·ªëi ∆∞u h√≥a updateSeatStates
  const updateSeatStates = useCallback(() => {
    if (!matrixSeats) return;

    // Kh·ªüi t·∫°o tr·∫°ng th√°i gh·∫ø
    const initialSeats: Record<
      string,
      { isHeld: boolean; heldByUser: boolean }
    > = {};

    // X·ª≠ l√Ω tr·∫°ng th√°i gh·∫ø t·ª´ ma tr·∫≠n
    for (const rowKey in matrixSeats) {
      const row = matrixSeats[rowKey];
      for (const seatKey in row) {
        const seat = row[seatKey];
        if (seat.status === "held" || seat.status === "booked") {
          initialSeats[seat.seatCode] = {
            isHeld: true,
            heldByUser: seat.heldByCurrentUser || false,
          };
        }
      }
    }

    // C·∫≠p nh·∫≠t state seats
    setSeats(initialSeats);

    // L·ªçc c√°c gh·∫ø h·ª£p l·ªá (kh√¥ng b·ªã ng∆∞·ªùi kh√°c gi·ªØ)
    const updatedSeats = nameSeatsRef.current.filter(
      (seatCode: any) =>
        !initialSeats[seatCode]?.isHeld || initialSeats[seatCode]?.heldByUser
    );

    // Ch·ªâ c·∫≠p nh·∫≠t khi c·∫ßn thi·∫øt
    if (updatedSeats.length !== nameSeatsRef.current.length) {
      // T√≠nh to√°n gi√° m·ªõi
      let newPrice = 0;
      updatedSeats.forEach((seatCode: any) => {
        for (const rowKey in matrixSeats) {
          const row = matrixSeats[rowKey];
          for (const seatKey in row) {
            const seat = row[seatKey];
            if (seat.seatCode === seatCode) {
              newPrice += Number(seat.price);
              break;
            }
          }
        }
      });

      // C·∫≠p nh·∫≠t state m·ªôt c√°ch ri√™ng bi·ªát, kh√¥ng l·ªìng nhau
      setNameSeats(updatedSeats);
      setTotalSeatPrice(newPrice);
      setQuantitySeats(updatedSeats.length);
    }

    // C·∫≠p nh·∫≠t ID gh·∫ø ƒë√£ ch·ªçn
    const validIds = selectedSeatIdsRef.current.filter((id: number) => {
      const seatCode = findSeatCodeById(id);
      return (
        seatCode &&
        (!initialSeats[seatCode]?.isHeld || initialSeats[seatCode]?.heldByUser)
      );
    });

    // Ch·ªâ c·∫≠p nh·∫≠t khi c·∫ßn thi·∫øt
    if (validIds.length !== selectedSeatIdsRef.current.length) {
      setSelectedSeatIds(validIds);
    }
  }, [
    matrixSeats,
    findSeatCodeById,
    setNameSeats,
    setQuantitySeats,
    setTotalSeatPrice,
    setSelectedSeatIds,
  ]);

  const holdSeatMutation = useMutation({
    mutationFn: async (seatIds: number[]) => {
      const { data } = await axios.post(
        "http://localhost:8000/api/hold-seats",
        {
          seats: seatIds,
          room_id: roomIdFromShowtimes,
          showtime_id: showtimeIdFromBooking,
        },
        {
          headers: { Authorization: `Bearer ${token}` },
        }
      );
      return data;
    },
    onSuccess: (data) => {
      message.success("ƒê√£ gi·ªØ gh·∫ø th√†nh c√¥ng!");

      // C·∫≠p nh·∫≠t d·ªØ li·ªáu gh·∫ø
      refetchSeatsData();

      try {
        const eventData = {
          timestamp: new Date().getTime(),
          seats: selectedSeatIdsRef.current,
          action: "hold",
          userId: userId,
        };
        localStorage.setItem("seat_update", JSON.stringify(eventData));
        const updateEvent = new CustomEvent("seatUpdateEvent", {
          detail: eventData,
        });
        window.dispatchEvent(updateEvent);
      } catch (e) {
        console.error("L·ªói khi l∆∞u v√†o localStorage:", e);
      }

      // G·ªçi callback ƒë·ªÉ chuy·ªÉn b∆∞·ªõc sau khi gi·ªØ gh·∫ø th√†nh c√¥ng
      if (onSeatHoldSuccess) {
        onSeatHoldSuccess();
      }
    },
    onError: (error) => {
      console.error("üö® L·ªói khi gi·ªØ gh·∫ø:", error);
      message.error("Kh√¥ng th·ªÉ gi·ªØ gh·∫ø. Vui l√≤ng th·ª≠ l·∫°i!");
    },
  });

  // X·ª≠ l√Ω khi gh·∫ø ƒë∆∞·ª£c click
  const handleSeatClick = useCallback(
    (seat: SeatType) => {
      // Ki·ªÉm tra gh·∫ø ƒë√£ b·ªã gi·ªØ ch∆∞a
      if (
        seats[seat.seatCode]?.isHeld ||
        seat.status === "held" ||
        seat.status === "booked"
      ) {
        console.log("Gh·∫ø n√†y ƒë√£ ƒë∆∞·ª£c gi·ªØ, kh√¥ng th·ªÉ ch·ªçn");
        return;
      }

      setHoldSeatId(seat.id);

      setNameSeats((prevSeats: string[]) => {
        let updatedSeats: string[];

        if (prevSeats.includes(seat.seatCode)) {
          // B·ªè ch·ªçn gh·∫ø
          updatedSeats = prevSeats.filter(
            (seatCode: string) => seatCode !== seat.seatCode
          );
          setSelectedSeatIds((prev: number[]) =>
            prev.filter((id: number) => id !== seat.id)
          );
        } else {
          // Ch·ªçn gh·∫ø
          updatedSeats = [...prevSeats, seat.seatCode];
          setSelectedSeatIds((prev: number[]) => [...prev, seat.id]);
        }

        // T√≠nh l·∫°i t·ªïng gi√°
        let updatedTotalPrice = 0;
        updatedSeats.forEach((seatCode) => {
          if (matrixSeats) {
            for (const rowKey in matrixSeats) {
              const row = matrixSeats[rowKey];
              for (const seatKey in row) {
                const seat = row[seatKey];
                if (seat.seatCode === seatCode) {
                  updatedTotalPrice += Number(seat.price);
                  break;
                }
              }
            }
          }
        });

        // C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng gh·∫ø v√† gi√° ti·ªÅn
        setQuantitySeats(updatedSeats.length);
        setTotalSeatPrice(updatedTotalPrice);

        return updatedSeats;
      });
    },
    [
      matrixSeats,
      seats,
      setHoldSeatId,
      setNameSeats,
      setQuantitySeats,
      setSelectedSeatIds,
      setTotalSeatPrice,
    ]
  );

  // X·ª≠ l√Ω khi nh·∫•n ti·∫øp t·ª•c
  const handleContinue = useCallback(() => {
    console.log("üîµ Gh·∫ø ƒëang gi·ªØ: ", selectedSeatIdsRef.current);

    if (selectedSeatIdsRef.current.length === 0) {
      console.warn("‚ö† Kh√¥ng c√≥ gh·∫ø n√†o ƒë∆∞·ª£c ch·ªçn!");
      message.warning("Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt gh·∫ø!");
      return;
    }

    holdSeatMutation.mutate(selectedSeatIdsRef.current);
  }, [holdSeatMutation]);

  // X·ª≠ l√Ω s·ª± ki·ªán c·∫≠p nh·∫≠t gh·∫ø
  const handleSeatUpdateEvent = useCallback(
    (event: CustomEvent) => {
      const data = event.detail;
      if (data.userId !== userId) {
        refetchSeatsData();
      }
    },
    [userId, refetchSeatsData]
  );

  // C·∫≠p nh·∫≠t t·ªïng gi√°
  useEffect(() => {
    setTotalPrice(totalSeatPrice);
  }, [totalSeatPrice, setTotalPrice]);

  // X·ª≠ l√Ω refetch khi c·∫ßn
  useEffect(() => {
    if (shouldRefetch) {
      refetchMatrix()
        .then(() => {
          console.log("‚úÖ ƒê√£ c·∫≠p nh·∫≠t d·ªØ li·ªáu th√†nh c√¥ng");
        })
        .catch((error) => {
          console.error("üö® L·ªói khi c·∫≠p nh·∫≠t d·ªØ li·ªáu:", error);
        })
        .finally(() => {
          setShouldRefetch(false);
        });
    }
  }, [shouldRefetch, refetchMatrix, setShouldRefetch]);

  // C·∫≠p nh·∫≠t tr·∫°ng th√°i gh·∫ø khi ma tr·∫≠n gh·∫ø thay ƒë·ªïi
  useEffect(() => {
    updateSeatStates();
  }, [matrixSeats, updateSeatStates]);

  // X·ª≠ l√Ω s·ª± ki·ªán storage
  useEffect(() => {
    const handleStorageChange = (e: StorageEvent) => {
      if (e.key === "seat_update") {
        try {
          const data = JSON.parse(e.newValue || "{}");
          if (data.userId !== userId) {
            refetchSeatsData();
          }
        } catch (error) {
          console.error("L·ªói khi x·ª≠ l√Ω s·ª± ki·ªán storage:", error);
        }
      }
    };

    window.addEventListener("storage", handleStorageChange);
    window.addEventListener(
      "seatUpdateEvent",
      handleSeatUpdateEvent as EventListener
    );

    return () => {
      window.removeEventListener("storage", handleStorageChange);
      window.removeEventListener(
        "seatUpdateEvent",
        handleSeatUpdateEvent as EventListener
      );
    };
  }, [userId, handleSeatUpdateEvent, refetchSeatsData]);

  // C·∫•u h√¨nh Pusher cho real-time
  useEffect(() => {
    if (!roomIdFromShowtimes || !showtimeIdFromBooking || isPusherRegistered) {
      return;
    }

    const channelName = `seats.${roomIdFromShowtimes}.${showtimeIdFromBooking}`;
    if (pusher.channel(channelName)) {
      pusher.unsubscribe(channelName);
    }

    const channel = pusher.subscribe(channelName);

    channel.bind("pusher:subscription_succeeded", () => {
      setIsPusherRegistered(true);

      if (!pusherEventHandlersRegistered.current) {
        channel.bind("seat-held", (data: any) => {
          let seatsArray: number[] = [];
          if (Array.isArray(data.seats)) {
            seatsArray = data.seats;
          } else if (data.seats && Array.isArray(data.seats.seats)) {
            seatsArray = data.seats.seats;
          } else if (Array.isArray(data)) {
            seatsArray = data;
          }

          if (seatsArray.length > 0) {
            if (data.userId !== userId) {
              const seatCodes = seatsArray
                .map((seatId) => findSeatCodeById(seatId))
                .filter(Boolean)
                .join(", ");
              if (seatCodes) {
                message.info(`Gh·∫ø ${seatCodes} v·ª´a ƒë∆∞·ª£c ng∆∞·ªùi kh√°c ch·ªçn`);
              }
              refetchMatrix();
            }

            // C·∫≠p nh·∫≠t tr·∫°ng th√°i gh·∫ø
            setSeats((prevSeats) => {
              const newSeats = { ...prevSeats };
              seatsArray.forEach((seatId) => {
                const seatCode = findSeatCodeById(seatId);
                if (seatCode) {
                  newSeats[seatCode] = {
                    isHeld: true,
                    heldByUser: data.userId === userId,
                  };
                }
              });
              return newSeats;
            });

            // Ch·ªâ c·∫≠p nh·∫≠t n·∫øu ng∆∞·ªùi d√πng kh√°c gi·ªØ gh·∫ø
            if (data.userId !== userId) {
              // C·∫≠p nh·∫≠t danh s√°ch gh·∫ø ƒë√£ ch·ªçn
              setNameSeats((prevNameSeats: string[]) => {
                const updatedSeats = prevNameSeats.filter(
                  (seatCode: string) => {
                    for (const seatId of seatsArray) {
                      if (findSeatCodeById(seatId) === seatCode) {
                        return false;
                      }
                    }
                    return true;
                  }
                );

                // Ch·ªâ t√≠nh to√°n l·∫°i gi√° n·∫øu c√≥ s·ª± thay ƒë·ªïi
                if (updatedSeats.length !== prevNameSeats.length) {
                  setQuantitySeats(updatedSeats.length);
                  // T√≠nh to√°n l·∫°i gi√°
                  let newPrice = 0;
                  updatedSeats.forEach((seatCode: string) => {
                    if (matrixSeats) {
                      for (const row in matrixSeats) {
                        for (const col in matrixSeats[row]) {
                          const seat = matrixSeats[row][col];
                          if (seat.seatCode === seatCode) {
                            newPrice += Number(seat.price);
                          }
                        }
                      }
                    }
                  });
                  setTotalSeatPrice(newPrice);
                }
                return updatedSeats;
              });

              // C·∫≠p nh·∫≠t danh s√°ch ID gh·∫ø ƒë√£ ch·ªçn
              setSelectedSeatIds((prev: number[]) =>
                prev.filter((id: number) => !seatsArray.includes(id))
              );
            }
          }
        });
        pusherEventHandlersRegistered.current = true;
      }
    });

    channel.bind("pusher:subscription_error", (error: any) => {
      console.error(`üö® L·ªói khi ƒëƒÉng k√Ω k√™nh ${channelName}:`, error);
    });

    return () => {
      channel.unbind("seat-held");
      pusher.unsubscribe(channelName);
      setIsPusherRegistered(false);
      pusherEventHandlersRegistered.current = false;
    };
  }, [
    roomIdFromShowtimes,
    showtimeIdFromBooking,
    userId,
    matrixSeats,
    findSeatCodeById,
    isPusherRegistered,
    refetchMatrix,
  ]);

  // C·∫•u h√¨nh k√™nh Pusher cho ng∆∞·ªùi d√πng
  useEffect(() => {
    if (!userId) return;

    const userChannelName = `user.${userId}`;
    const userChannel = pusher.subscribe(userChannelName);

    userChannel.bind("hold-seat-ack", (data: any) => {
      refetchMatrix();
    });

    return () => {
      userChannel.unbind("hold-seat-ack");
      pusher.unsubscribe(userChannelName);
    };
  }, [userId, refetchMatrix]);

  // Thi·∫øt l·∫≠p polling v·ªõi kho·∫£ng th·ªùi gian c·ªë ƒë·ªãnh
  useEffect(() => {
    if (roomIdFromShowtimes && showtimeIdFromBooking) {
      if (pollingIntervalRef.current) {
        clearInterval(pollingIntervalRef.current);
      }

      // Polling trong kho·∫£ng th·ªùi gian d√†i h∆°n (10 gi√¢y thay v√¨ 5 gi√¢y)
      pollingIntervalRef.current = window.setInterval(() => {
        refetchMatrix();
      }, 10000) as unknown as number;

      refetchMatrix();
    }

    return () => {
      if (pollingIntervalRef.current) {
        clearInterval(pollingIntervalRef.current);
        pollingIntervalRef.current = null;
      }
    };
  }, [roomIdFromShowtimes, showtimeIdFromBooking, refetchMatrix]);

  // X·ª≠ l√Ω visibility change
  useEffect(() => {
    const handleVisibilityChange = () => {
      if (document.visibilityState === "visible") {
        refetchMatrix();
      }
    };

    document.addEventListener("visibilitychange", handleVisibilityChange);

    return () => {
      document.removeEventListener("visibilitychange", handleVisibilityChange);
    };
  }, [refetchMatrix]);

  // K·∫øt n·ªëi h√†m onContinue v·ªõi handleContinue, ƒë·ªÉ tr√°nh v√≤ng l·∫∑p v√¥ h·∫°n
  useEffect(() => {
    if (onContinue) {
      onContinue(handleContinue);
    }
  }, [onContinue, handleContinue]);

  return (
    <div className={`box-main-left ${className}`}>
      <div className="box-showtimes">
        <span className="change-showtimes">ƒê·ªïi su·∫•t chi·∫øu:</span>
        <span>13:00</span>
        <span>13:00</span>
        <span>13:00</span>
        <span>13:00</span>
        <span>13:00</span>
      </div>
      <div className="booking-seat">
        <div>
          <Card>
            <div className="screen">M√ÄN H√åNH</div>

            <div className="matrix-seat">
              {matrixSeats &&
                Object.entries(matrixSeats).map(
                  ([rowLabel, rowData]: any, rowIndex) => (
                    <div
                      key={`row-${rowLabel}-${rowIndex}`}
                      className="row-seats"
                    >
                      <div className="col-seats">{rowLabel}</div>
                      {Object.values(rowData).map((seat: any) => {
                        const isSelected = nameSeats.includes(seat.seatCode);
                        const seatState = seats[seat.seatCode] || {};
                        const isHeld =
                          seatState.isHeld ||
                          seat.status === "held" ||
                          seat.status === "booked";

                        return (
                          <button
                            className="seat-name"
                            key={`seat-${seat.id}`}
                            onClick={() => handleSeatClick(seat)}
                            disabled={isHeld}
                            style={{
                              background: isHeld
                                ? "rgb(241, 153, 2)"
                                : isSelected
                                ? "#52c41a"
                                : "transparent",
                              border:
                                seat.type === "VIP"
                                  ? "1px solid #1890ff"
                                  : seat.type === "Sweetbox"
                                  ? "1px solid #f5222d"
                                  : "1px solid #8c8c8c",
                              color:
                                seat.type === "VIP"
                                  ? "#1890ff"
                                  : seat.type === "Sweetbox"
                                  ? "#f5222d"
                                  : "black",
                              cursor: isHeld ? "not-allowed" : "pointer",
                              opacity: isHeld ? 0.6 : 1,
                            }}
                          >
                            {seat.seatCode}
                          </button>
                        );
                      })}
                    </div>
                  )
                )}
            </div>
          </Card>
        </div>
      </div>
    </div>
  );
};

export default BookingSeat;
